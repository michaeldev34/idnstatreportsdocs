"""
PDF Report Builder

Generates PDF reports from analysis results.
"""

import pandas as pd
from typing import Dict, Any
from datetime import datetime


class PDFReportBuilder:
    """
    Builds PDF reports from statistical analysis results.
    
    Uses HTML templates and converts to PDF.
    """
    
    def __init__(self, label: str = "Statistical Report"):
        """
        Args:
            label: Report title/label
        """
        self.label = label
        self.sections = []
    
    def build(self, metadata: Dict[str, Any], kpis: pd.DataFrame,
              preprocessing: Dict[str, Any], models: Dict[str, Any],
              explanation: Dict[str, Any]) -> str:
        """
        Build complete PDF report.
        
        Args:
            metadata: Dataset metadata
            kpis: KPI results DataFrame
            preprocessing: Preprocessing results
            models: Model results
            explanation: Explanation results
            
        Returns:
            Path to generated PDF file
        """
        # Build HTML content
        html_content = self._build_html(metadata, kpis, preprocessing, models, explanation)
        
        # Convert to PDF (simplified - in production use weasyprint or reportlab)
        pdf_path = self._html_to_pdf(html_content)
        
        return pdf_path
    
    def _build_html(self, metadata: Dict[str, Any], kpis: pd.DataFrame,
                   preprocessing: Dict[str, Any], models: Dict[str, Any],
                   explanation: Dict[str, Any]) -> str:
        """Build HTML content for report."""
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>{self.label}</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    margin: 40px;
                    line-height: 1.6;
                }}
                h1 {{
                    color: #2c3e50;
                    border-bottom: 3px solid #3498db;
                    padding-bottom: 10px;
                }}
                h2 {{
                    color: #34495e;
                    margin-top: 30px;
                    border-bottom: 2px solid #95a5a6;
                    padding-bottom: 5px;
                }}
                table {{
                    border-collapse: collapse;
                    width: 100%;
                    margin: 20px 0;
                }}
                th, td {{
                    border: 1px solid #ddd;
                    padding: 12px;
                    text-align: left;
                }}
                th {{
                    background-color: #3498db;
                    color: white;
                }}
                tr:nth-child(even) {{
                    background-color: #f2f2f2;
                }}
                .metadata {{
                    background-color: #ecf0f1;
                    padding: 15px;
                    border-radius: 5px;
                    margin: 20px 0;
                }}
                .footer {{
                    margin-top: 50px;
                    text-align: center;
                    color: #7f8c8d;
                    font-size: 0.9em;
                }}
                .chart {{
                    margin: 20px 0;
                    text-align: center;
                }}
                .chart img {{
                    max-width: 100%;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }}
                .interpretation {{
                    background-color: #f8f9fa;
                    padding: 20px;
                    border-left: 4px solid #3498db;
                    margin: 20px 0;
                    white-space: pre-wrap;
                }}
            </style>
        </head>
        <body>
            <h1>{self.label}</h1>
            <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

            <h2>1. Dataset Metadata</h2>
            <div class="metadata">
                {self._format_metadata(metadata)}
            </div>

            <h2>2. Key Performance Indicators (KPIs)</h2>
            <p><em>Per-observation KPIs calculated for each time period. Statistics show the distribution across all observations.</em></p>
            {self._format_kpis(kpis)}

            <h2>3. Preprocessing & Tests</h2>
            {self._format_preprocessing(preprocessing)}

            <h2>4. Statistical Models</h2>
            {self._format_models(models)}

            <h2>5. Interpretation & Forecast</h2>
            {self._format_explanation(explanation)}

            <h2>6. Visualizations</h2>
            {self._format_charts(explanation)}

            <div class="footer">
                <p>Generated by AutoStat - Enterprise Statistical Automation Engine</p>
            </div>
        </body>
        </html>
        """
        
        return html
    
    def _format_metadata(self, metadata: Dict[str, Any]) -> str:
        """Format metadata as HTML."""
        html = "<ul>"
        for key, value in metadata.items():
            html += f"<li><strong>{key}:</strong> {value}</li>"
        html += "</ul>"
        return html
    
    def _format_dataframe(self, df: pd.DataFrame) -> str:
        """Format DataFrame as HTML table."""
        if df.empty:
            return "<p>No data available.</p>"
        return df.to_html(index=False, classes='data-table')

    def _format_kpis(self, kpis: pd.DataFrame) -> str:
        """Format KPI summary table with per-observation statistics."""
        if kpis.empty:
            return "<p>No KPIs calculated.</p>"

        html = "<table class='data-table'>"

        # Header row
        html += "<tr>"
        html += "<th>Category</th>"
        html += "<th>KPI</th>"
        html += "<th>Mean</th>"
        html += "<th>Median</th>"
        html += "<th>Current</th>"
        html += "<th>Std Dev</th>"
        html += "<th>Min</th>"
        html += "<th>Max</th>"
        html += "<th>N</th>"
        html += "<th>Unit</th>"
        html += "</tr>"

        # Data rows
        for _, row in kpis.iterrows():
            html += "<tr>"
            html += f"<td><strong>{row.get('category', 'N/A')}</strong></td>"
            html += f"<td>{row.get('kpi', 'N/A')}</td>"
            html += f"<td>{row.get('mean', 'N/A')}</td>"
            html += f"<td>{row.get('median', 'N/A')}</td>"
            html += f"<td>{row.get('current', 'N/A')}</td>"
            html += f"<td>{row.get('std', 'N/A')}</td>"
            html += f"<td>{row.get('min', 'N/A')}</td>"
            html += f"<td>{row.get('max', 'N/A')}</td>"
            html += f"<td>{row.get('n_observations', 'N/A')}</td>"
            html += f"<td>{row.get('unit', '')}</td>"
            html += "</tr>"

        html += "</table>"

        # Add interpretation note
        html += """
        <div style="margin-top: 15px; padding: 10px; background: #f0f8ff; border-radius: 5px;">
            <strong>Reading Guide:</strong>
            <ul style="margin: 5px 0;">
                <li><strong>Mean:</strong> Average KPI value across all observations</li>
                <li><strong>Median:</strong> Middle value (50th percentile)</li>
                <li><strong>Current:</strong> Most recent observation value</li>
                <li><strong>Std Dev:</strong> Variability/volatility of the KPI</li>
                <li><strong>N:</strong> Number of valid observations</li>
            </ul>
        </div>
        """

        return html

    def _format_preprocessing(self, preprocessing: Dict[str, Any]) -> str:
        """Format preprocessing results."""
        if not preprocessing or 'test_results' not in preprocessing:
            return "<p>No preprocessing results available.</p>"

        test_results = preprocessing['test_results']
        integration_orders = preprocessing.get('integration_orders', {})

        html = ""

        # Add Order of Integration Summary Table (if available)
        if integration_orders:
            html += "<h3>Order of Integration Summary</h3>"
            html += "<table><tr><th>Variable</th><th>Order</th><th>Notation</th><th>Interpretation</th></tr>"
            for var_name, integration_result in integration_orders.items():
                order = integration_result.get('order', 'N/A')
                notation = integration_result.get('notation', 'N/A')
                interpretation = integration_result.get('interpretation', 'N/A')

                html += f"<tr><td><strong>{var_name}</strong></td><td>{order}</td><td>{notation}</td><td>{interpretation}</td></tr>"
            html += "</table>"

        # Add All Test Results (Result column hidden, only Test and Passed shown)
        # Note: Result data is printed to console for debugging but not shown in report
        html += "<h3>All Preprocessing Tests</h3>"
        html += "<table><tr><th>Test</th><th>Passed</th></tr>"
        for result in test_results:
            test_name = result.get('test', 'Unknown')
            passed = result.get('passed', 'N/A')
            passed_display = '✓ Yes' if passed == True else ('✗ No' if passed == False else str(passed))

            # Print result to console for debugging (not shown in report)
            test_result = result.get('result', {})
            if test_result:
                print(f"[DEBUG] {test_name}: {test_result}")

            html += f"<tr><td>{test_name}</td><td>{passed_display}</td></tr>"
        html += "</table>"

        return html
    
    def _format_models(self, models: Dict[str, Any]) -> str:
        """Format model results."""
        if not models or 'results' not in models:
            return "<p>No model results available.</p>"
        
        results = models['results']
        
        html = "<table><tr><th>Model</th><th>R²</th><th>Details</th></tr>"
        for result in results:
            model_name = result.get('model', 'Unknown')
            r_squared = result.get('r_squared', 'N/A')
            
            # Extract key details
            details = []
            if 'n_obs' in result:
                details.append(f"N={result['n_obs']}")
            if 'mse' in result:
                details.append(f"MSE={result['mse']:.4f}")
            
            details_str = ', '.join(details) if details else 'See full results'
            
            html += f"<tr><td>{model_name}</td><td>{r_squared}</td><td>{details_str}</td></tr>"
        html += "</table>"
        
        return html
    
    def _format_explanation(self, explanation: Dict[str, Any]) -> str:
        """Format explanation results with forecast table."""
        html = ""

        if 'interpretation' in explanation:
            html += f"<h3>Interpretation</h3><div class='interpretation'>{explanation['interpretation']}</div>"

        if 'forecast' in explanation:
            forecast_data = explanation['forecast']
            if forecast_data.get('forecast_table') is not None:
                html += "<h3>Forecast (Next 30 Periods)</h3>"
                forecast_df = forecast_data['forecast_table']
                # Show only first 10 rows for readability
                html += self._format_dataframe(forecast_df.head(10))
                if len(forecast_df) > 10:
                    html += f"<p><em>Showing first 10 of {len(forecast_df)} forecasted periods</em></p>"
            elif 'error' in forecast_data:
                html += f"<h3>Forecast</h3><p><em>{forecast_data['error']}</em></p>"

        return html if html else "<p>No explanation available.</p>"

    def _format_charts(self, explanation: Dict[str, Any]) -> str:
        """Format charts with embedded base64 images organized by department."""
        html = ""

        if 'charts' in explanation and explanation['charts']:
            charts = explanation['charts']

            # Organize charts by type and department
            time_series_charts = [c for c in charts if c.get('type') == 'time_series_dept']
            correlation_charts = [c for c in charts if c.get('type') == 'correlation_dept']
            distribution_charts = [c for c in charts if c.get('type') == 'distribution_dept']
            forecast_charts = [c for c in charts if c.get('type') == 'forecast']

            # Time Series by Department
            if time_series_charts:
                html += "<h3>Time Series Analysis by Department</h3>"
                for chart in time_series_charts:
                    if 'error' not in chart:
                        title = chart.get('title', 'Chart')
                        image_base64 = chart.get('image', '')
                        if image_base64:
                            html += f"""
                            <div class="chart">
                                <h4>{title}</h4>
                                <img src="data:image/png;base64,{image_base64}" alt="{title}">
                            </div>
                            """

            # Correlation Heatmaps by Department
            if correlation_charts:
                html += "<h3>Correlation Analysis by Department</h3>"
                for chart in correlation_charts:
                    if 'error' not in chart:
                        title = chart.get('title', 'Chart')
                        image_base64 = chart.get('image', '')
                        if image_base64:
                            html += f"""
                            <div class="chart">
                                <h4>{title}</h4>
                                <img src="data:image/png;base64,{image_base64}" alt="{title}">
                            </div>
                            """

            # Distribution Plots by Department
            if distribution_charts:
                html += "<h3>Distribution Analysis by Department</h3>"
                for chart in distribution_charts:
                    if 'error' not in chart:
                        title = chart.get('title', 'Chart')
                        image_base64 = chart.get('image', '')
                        if image_base64:
                            html += f"""
                            <div class="chart">
                                <h4>{title}</h4>
                                <img src="data:image/png;base64,{image_base64}" alt="{title}">
                            </div>
                            """

            # Forecast Visualization
            if forecast_charts:
                html += "<h3>Forecast Visualization</h3>"
                for chart in forecast_charts:
                    if 'error' not in chart:
                        title = chart.get('title', 'Chart')
                        image_base64 = chart.get('image', '')
                        if image_base64:
                            html += f"""
                            <div class="chart">
                                <h4>{title}</h4>
                                <img src="data:image/png;base64,{image_base64}" alt="{title}">
                            </div>
                            """

            # IRF (Impulse Response Function) Visualization
            irf_charts = [c for c in charts if c.get('type') == 'irf']
            if irf_charts:
                html += "<h3>Impulse Response Functions</h3>"
                html += "<p><em>Shows the dynamic response of variables to a one-unit shock.</em></p>"
                for chart in irf_charts:
                    if 'error' not in chart:
                        title = chart.get('title', 'IRF')
                        image_base64 = chart.get('image', '')
                        if image_base64:
                            html += f"""
                            <div class="chart">
                                <h4>{title}</h4>
                                <img src="data:image/png;base64,{image_base64}" alt="{title}">
                            </div>
                            """

        return html if html else "<p>No charts available.</p>"
    
    def _html_to_pdf(self, html_content: str) -> str:
        """
        Convert HTML to PDF.
        
        In production, use weasyprint or reportlab.
        For now, save as HTML.
        """
        output_path = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return output_path

